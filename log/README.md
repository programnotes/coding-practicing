# log

一个好的Logger应该提供以下能力:

- 支持把日志写入到多个输出流中，比如可以选择性的让测试、开发环境同时向控制台和日志文件输出日志，生产环境只输出到文件中。
- 支持多级别的日志等级，比如常见的有：TRACE，DEBUG，INFO，WARN，ERROR 等。
- 支持结构化输出，结构化输出现在常用的就是JSON形式的，这样可以统一日志平台，通过 logstash 之类的组件直接把日志聚合到日志平台上去。
- 需要支持日志切割 -- log rotation， 按照日期、时间间隔或者文件大小对日志进行切割。
- 在 Log Entry 中（就是每行记录）除了主动记录的信息外，还要包括如打印日志的函数、所在的文件、行号、记录时间等。

## go原生log

缺点

- 仅限基本的日志级别,只有一个Print选项。不支持INFO/DEBUG等多个级别。
- 对于错误日志，它有Fatal和Panic
  - Fatal日志通过调用os.Exit(1)来结束程序
  - Panic日志在写入日志消息之后抛出一个panic
  - 但是它缺少一个ERROR日志级别，这个级别可以在不抛出panic或退出程序的情况下记录错误
- 缺乏结构化日志格式的能力——只支持简单文本输出，不能把日志记录格式化成 JSON 格式。
- 不提供日志切割的能力。

## 获取项目根目录绝对路径

几种实现方式:

- os.Getwd()
- os.Args[0]
- runtime.Caller

### os.GetWd

获取进程的当前工作目录,wd—working directory （工作目录）,当进程执行目录不在项目目录下时获取的路径就和项目目录不同

### os.Args[0]

os.Args这个列表里保存的是程序的启动参数，而参数0按照约定是程序的可执行文件名

使用go run时返回的是临时目录,其他情况都能正常

### runtime.Caller
